Arbitrary write due to unchecked array index in function vmd_decode.

Adapted from 'Vulnerability Extrapolation' paper:

http://user.informatik.uni-goettingen.de/~krieck/docs/2011-woot.pdf

vmd_decode reads the frame dimensions and offsets specified by the
individual frame at (1) and (2) and then calculates an offset into the
pixel buffer based on these values at (3). The function fails to
validate whether the given offset references a location within the
buffer. Therefore, as user-supplied data is copied to the specified
location at (4), an attacker can corrupt memory by choosing an offset
outside of the buffer.

static void vmd_decode(VmdVideoContext *s)
{

    frame_x = AV_RL16(&s->buf[6]); // (1)
    frame_y = AV_RL16(&s->buf[8]); // (2)
    // ...

    frame_x -= s->x_off;
    frame_y -= s->y_off;
    
    /* check if there is a new palette */
    if (s->buf[15] & 0x02) {
        p += 2;
        palette32 = (unsigned int *)s->palette;
        for (i = 0; i < PALETTE_COUNT; i++) {
            r = *p++ * 4;
            g = *p++ * 4;
            b = *p++ * 4;
            palette32[i] = (r << 16) | (g << 8) | (b);
        }
        s->size -= (256 * 3 + 2);
    }
    if (s->size >= 0) {
        // ...
        dp = &s->frame.data[0][frame_y * s->frame.linesize[0] + frame_x]; // (3)
        dp_size = s->frame.linesize[0] * s->avctx->height;
        pp = &s->prev_frame.data[0][frame_y * s->prev_frame.linesize[0] + frame_x];
        switch (meth) {
	...
	case 2:
            for (i = 0; i < frame_height; i++) {
                memcpy(dp, pb, frame_width);

	...}
...}...} ...}
